# 一：背景

但因其实现存在并发性能差、缓存命中率低等问题，该特性在MySQL 5.7.20标记为不推荐使用，在MySQL 8.0.3里被删除。



# 二：源码

## 2.1 重要结构体

| Query_cache                 | 对整个Query Cache进行管理，负责提供接口供Server调用。        |
| --------------------------- | ------------------------------------------------------------ |
| Query_cache_block           | Query Cache中的所有存储都是以Query_cache_block来组织的。每一个Query_cache_block的格式都是Block_header + data. |
| Query_cache_table           | 用来记录单个数据表的Block_header                             |
| Query_cache_block_table     | 用来存储与Query相关的数据表的Block_header。每一个数据表都有一个独立的Query_cache_block_table结构对应。与Query_cache_table的区别是，所有Query使用的同一个数据表对应同一个Query_cache_table |
| Query_cache_query           | 用来记录Query的Block_header                                  |
| Query_cache_result          | 用来记录结果集的Block_header                                 |
| Query_cache_memory_bin      | 用来管理Query Cache的内存使用，Query Cache的整体内存被划分为多个bins。该结构在Query Cache初始化的过程中完成。请参考下面Query Cache内存初始化部分。 |
| Query_cache_memory_bin_step | 用来辅助初始化Query_cache_memory_bins，记录内存管理的每一层的bins内存分配的大小。请参考下面Query Cache内存初始化部分 |
| Query_cache_query_flags     | 用来记录影响Query返回结果的环境变量，比如sql_mode，字符集，time_zone等 |

## 2.2 参数

```sql
mysql> SHOW VARIABLES LIKE '%query_cache%';
+------------------------------+---------+
| Variable_name                | Value   |
+------------------------------+---------+
| have_query_cache             | YES     |---缓存是否可用
| query_cache_limit            | 1048576 |---可缓存结果的最大字节
| query_cache_min_res_unit     | 4096    |---每个缓存最小占用空间
| query_cache_size             | 1048576 |---查询缓存的大小
| query_cache_type             | OFF     |---禁用/启用缓存机制
| query_cache_wlock_invalidate | OFF     |---控制写锁定时是否失效缓存
+------------------------------+---------+
6 rows in set (0.01 sec)

mysql> show global status like 'QCache%';
+-------------------------+----------+
| Variable_name           | Value    |
+-------------------------+----------+
| Qcache_free_blocks      | 1        |
| Qcache_free_memory      | 41925840 |--空闲的内存
| Qcache_hits             | 0        |--查询缓存命中的次数
| Qcache_inserts          | 0        |--新插入的缓存次数
| Qcache_lowmem_prunes    | 0        |--lru置换出来的次数
| Qcache_not_cached       | 0        |--没有缓存的次数
| Qcache_queries_in_cache | 0        |
| Qcache_total_blocks     | 1        |
+-------------------------+----------+
```

### 启动流程

```c++
|-->init_server_components()
|		|-->init_server_query_cache() //启动时初始化query cache
|		|		|-->1. query_cache.set_min_res_unit() //设置query)cache block 最小值4k(默认)
|		|		|-->2. query_cache.init()//初始化锁
|		|		|-->3. Query_cache::resize() //初始化内存池
```

### Query cache类

```c++
class Query_cache
{
public:
  /* Info */
  ulong query_cache_size, query_cache_limit;
  /* statistics */
  ulong free_memory, queries_in_cache, hits, inserts, refused,
    free_memory_blocks, total_blocks, lowmem_prunes;


private:
#ifndef NDEBUG
  my_thread_id m_cache_lock_thread_id;
#endif
  mysql_cond_t COND_cache_status_changed;
  enum Cache_lock_status { UNLOCKED, LOCKED_NO_WAIT, LOCKED };
  Cache_lock_status m_cache_lock_status;

  bool m_query_cache_is_disabled;

  void free_query_internal(Query_cache_block *point);
  void invalidate_table_internal(THD *thd, uchar *key, size_t key_length);
  void disable_query_cache(void) { m_query_cache_is_disabled= TRUE; }

protected:
  /*
    The following mutex is locked when searching or changing global
    query, tables lists or hashes. When we are operating inside the
    query structure we locked an internal query block mutex.
    LOCK SEQUENCE (to prevent deadlocks):
      1. structure_guard_mutex
      2. query block (for operation inside query (query block/results))

    Thread doing cache flush releases the mutex once it sets
    m_cache_status flag, so other threads may bypass the cache as
    if it is disabled, not waiting for reset to finish.  The exception
    is other threads that were going to do cache flush---they'll wait
    till the end of a flush operation.
  */
  mysql_mutex_t structure_guard_mutex;
  uchar *cache;					// cache memory
  Query_cache_block *first_block;		// physical location block list
  Query_cache_block *queries_blocks;		// query list (LIFO)
  Query_cache_block *tables_blocks;

  Query_cache_memory_bin *bins;			// free block lists
  Query_cache_memory_bin_step *steps;		// bins spacing info
  HASH queries, tables;						//两个关键的hashtable 存储所有queries，以及所有tables
  /* options */
  ulong min_allocation_unit, min_result_data_size;
  uint def_query_hash_size, def_table_hash_size;
  
  uint mem_bin_num, mem_bin_steps;		// See at init_cache & find_bin

  my_bool initialized;
}
```



### Query cache内存管理

1. 一次性申请query_cache_size大小的内存空间。
2. 初始化内存管理方式。

Query cache对于整个内存的管理是将整个内存块划分多层(bin)大小不同的多个query_cache_memory_bins, 具体

```c++
class Query_cache {
  Query_cache_memory_bin *bins;
};

// 一个bin元素维护一条空闲内存块链表，链表有如下特征（设当前数组下标为i）：
// 1、链表管理块大小范围在bins[i].size ~ bins[i-1].size之间；
// 2、链表中空闲内存块从小到大有序；
// 3、链表为双向链表，并且头尾相连。
struct Query_cache_memory_bin {
  Query_cache_block *free_blocks; // 空闲内存块链表
  ulong size; // 链表管理块大小范围下限，最小为512B
  uint number; // 当前链表长度 
};

```

![img](https://pic1.zhimg.com/v2-3c3aa383f823e0ced934d6aa4f632c4c_r.jpg)

（1）初始化阶段会调用init_cache()生成多个bins链表，bins[0]的free_block是整个空间。

（2）当需要申请新的数据块时，Query cache首先寻找大小最为接近的bins进行匹配，判断bins中有没有free_block。如果有则使用；如果没有则从其上一个bins中寻找free_block(bins是按照空间大小降序排列的，上层的bins大小要比下层的bins空间大），直到找到合适大小的一个。 如果最后没有找到合适大小的，Query cache将启动淘汰机制进行淘汰，以满足空间申请的需求。

（3）内存回收：在需要申请内存块时，如果没有找到合适大小的free block, Query cache将启动淘汰机制来淘汰最旧的缓存记录，释放的block将被分配到对应大小的bins中。

 （4）碎片合并：当回收的free block和bins中其他free block地址相邻， 当前回收的free block将会和相邻的free block进行合并，重新插入到大小合适的bins中。

![img](https://pica.zhimg.com/v2-38a179af00f0d47dda5366be859b2d56_r.jpg)



### Query cache核心函数

1. Query_cache::try_lock() : 加锁逻辑
2. Query_cache::insert() : 插入数据data逻辑
3. Query_cache::store_query()：把query中设计到的table信息保存下来
4. Query_cache::send_result_to_client(): 把sql对应的data发送
5. Query_cache::invalidate()

####  发送流程 send_result_to_client()

```c++
|-->mysql_parse()//在语法解析之前就发送
|	|-->Query_cache::send_result_to_client()
|		|-->1. 判断querycache开关是否打开
				2. 判断是不是xa事务
        3. 判断是不是select
        4. 判断是不是有selec_no_cache
|		|-->Query_cache::try_lock() //加锁，串行访问query_cache ？
|		|-->填充flags
|		|-->make_cache_key() //query + \0 + current DB (if any) + cache flags
|		|-->my_hash_search() //根据上面的cache_key查找到具体的query_block	
|		|-->BLOCK_LOCK_RD(query_block);//对这个query-block加rlock
|		|-->//检查各种权限
|		|-->send_data_in_chunks()//遍历结果块并发送
|		|-->trans_commit_stmt()//提交事务
|		|-->unlock() //解锁query_cache
```

#### 插入table流程 store_query()

```c++
|-->Sql_cmd_dml::execute()
|		|-->Query_cache::store_query()
|		|		|-->//各种状态检查
|		|		|-->Query_cache::is_cacheable()//判断这条sql是否可以加入到query_cache中
|		|		|		|-->Query_cache::process_and_count_tables() //找出sql中所有的table信息
|		|		|-->//保存flags信息
|		|		|-->Query_cache::try_lock() //加锁
|		|		|-->ask_handler_allowance() //让存储引擎来判断是否可以cache？？还需要吗？
|		|		|-->make_cache_key() //构建cache_key
|		|		|-->my_hash_search()//然后还得判断是否有其他thread也构建了cache_key。这样的设计合理吗？
|		|		|-->Query_cache::write_block_data()//将cache_key生成block_data
|		|		|-->my_hash_insert() //将query_block插入到queries(hashtable)
|		|		|-->register_all_tables()//将设计的表插入到tables(hashtable)
|		|		|		|-->Query_cache::register_tables_from_list()
|		|		|		|		|-->Query_cache::insert_table() //表插入query_block中
|  	|		|		|		|		|-->Query_cache::write_block_data() //写入table的block
```

#### 缓存result到query_cache中 query_cache_insert()

```c++
|-->net_write_packet()
|		|-->query_cache_insert()
|		|		|-->Query_cache::insert()
|		|		|		|-->try_lock() //加锁
|		|		|		|-->BLOCK_LOCK_WR(query_block);//获取query_block的写锁能力
|		|		|		|-->Query_cache::append_result_data() //添加result信息
|		|		|		|		|-->Query_cache::write_result_data() //写入
|		|		|		|-->header->result(result);header->last_pkt_nr = pkt_nr;//更新查询结果指针和包序号
|		|		|		|-->BLOCK_UNLOCK_WR(query_block);//解写锁

```

#### dml的invalidate流程如下：

1、 通过数据库 + 表名在Query_cache::tables哈希表中找到table block；

2、 通过table block中Query_cache_block_table链表头找到相关query block；

3、 根据query block的result block指针，找到对应的result block；

4、 对上述block进行释放。


