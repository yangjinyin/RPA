# 一：表空间关键page

![img](https://img2022.cnblogs.com/blog/1506178/202205/1506178-20220531104513298-574039244.png)



每个独立表空间都对应磁盘上的一个物理文件，命名形式为{table_name}.ibd。物理文件按page切分，这些page主要分为两类：存储表空间元信息的page和存储表空间用户数据的page。

表空间的前三个page为主要的元信息page。如下图：

<img src="http://mysql.taobao.org/monthly/pic/201910/ibd_file_overview.png" alt="img" style="zoom:%;" />

## 1.1 **FSP HEADER PAGE**

FSP header page是表空间的root page，存储表空间关键元数据信息。由page file header、fsp header、xdes entries三大部分构成。完整格式如下图：

![img](http://mysql.taobao.org/monthly/pic/201910/ibd_header_page.png)

### 1.1.1 FIL Header：38个字节

- **FIL_PAGE_ARCH_LOG_NO_OR_SPACE_ID**：存储表空间的space id
- **FIL_PAGE_SRV_VERSION**：本来被用于存储前一个页面id，在root page中被用来存储SERVER版本号
- **FIL_PAGE_SPACE_VERSION**：本来被用于存储后一个页面id，在root page中被用来存储TABLE SPACE版本号



### 1..1.2 fsp header

  主要存储表空间元信息，维护关键结构分配链表，主要成员有：

- **FSP_SIZE**：表空间大小，以Page数量计算
- **FSP_FREE_LIMIT**：目前在空闲的`Extent`上最小的尚未被初始化的`Page`的`Page Number
- **FSP_FREE**：空闲extent链表，链表中的每一项为代表extent的xdes，所谓空闲extent是指该extent内所有page均未被使用
- **FSP_FREE_FRAG**：free frag extent链表，链表中的每一项为代表extent的xdes，所谓free frag extent是指该extent内有部分page未被使用
- **FSP_FULL_FRAG**：full frag extent链表，链表中的每一项为代表extent的xdes，所谓full frag extent是指该extent内所有Page均已被使用
- **FSP_SEG_ID**：下次待分配的segment id，每次分配新segment时均会使用该字段作为segment id，并将该字段值+1写回
- **FSP_SEG_INODES_FULL**：full inode page链表，链表中的每一项为inode page，该链表中的每个inode page内的inode entry都已经被使用
- **FSP_SEG_INODES_FREE**：free inode page链表，链表中的每一项为inode page，该链表中的每个inode page内上有空闲inode entry可分配



### 1.1.3 XDES

描述extent的xdes（extent descriptor）信息，每个xdes page中均存储256个xdes，描述接下来连续的256个extent（一个extent有64个page，一个page 16kb，一个extent 1MB）

<img src="http://mysql.taobao.org/monthly/pic/201910/ibd_header_xdes_arr.png" alt="img" style="zoom:50%;" />

每个XDES项占据40字节，因此，一个xdes page可跟踪其后的256个extent的分配情况，XDES结构如下：

![img](http://mysql.taobao.org/monthly/pic/201910/ibd_xdes.png)

## 1.2 index PAGE

- `innodb page`的大小由`innodb_page_size`确定，默认为`16 KB`

- `index page`的结构图如下所示

  ![img](http://mysql.taobao.org/monthly/pic/201908/2019-08-29-zanye-01.png)

  ### 1.2.1 file header

  ![img](http://mysql.taobao.org/monthly/pic/201908/2019-08-29-zanye-02.png)

  - `Offset(Page Number)`：每个表空间从0开始，该值乘以数据页的大小得到数据页在文件中的起始偏移量。在`redo log`通过记录该值指示操作修改了哪个页面
  - `Previous/Next Page`：两个指针，按照逻辑顺序（一般是主键顺序）组织成双向链表。这也可以看到，聚集索引指的是逻辑上的聚集，而物理上实际不一定是连续的。通过双向链表可以很方便进行范围查找
  - `FIL_PAGE_LSN`：最新被修改的`LSN`，用于实现幂等特性
  - `FIL_PAGE_TYPE`：可能的`page type`有`index、undo、blob`等十多种
  - `FIL_PAGE_ARCH_LOG_NO_OR_SPACE_ID`：`space id，redo log`通过该值与`page no`唯一标识一个`page`

### 1.2.2 index page header

​     ![img](http://mysql.taobao.org/monthly/pic/201908/2019-08-29-zanye-03.png)

- ```plaintext
  Number of Directory Slots
  ```

  ：目录槽的个数。

  - 从`index page overview`图中看到，记录从上往下涨，而目录槽从下往上堆。
  - `Page Directory`是一个稀疏目录，按照`key`排序。里面的每个`slot`指向了本`slot`中的第一个记录。
  - 当定位到一个`page`时，先通过`page directory`找到对应的`slot`，然后找到`slot`中的第一个记录，通过遍历`slot`内的所有记录，最终找到指定的记录
  - `slot`上的记录数不能太多也不能太少，对于普通记录在`[4,8]`区间内，如果超过则要重新整理，方法是将`slot`按照中间点拆分成两个，后续的目录进行平移（为了给新的`slot`腾出空间）

- `PAGE_HEAP_TOP`：空闲空间的起始地址，

- `PAGE_N_HEAP`：最高位用来标记格式（`compact`还是`redundant`），不会减少，只要有空闲空间记录就会增加

- ```plaintext
  PAGE_FREE
  ```

  ：删除记录的链表。

  - 当一个记录被删除时，会先被标记为`delete`状态，随后被`purge`线程彻底删除，最后用头插法加入这个链表。
  - 当一个记录被插入时，会先去`page_free`找，不行再用空闲空间（`heap`）

- `PAGE_LAST_INSERT, PAGE_DIRECTION, PAGE_N_DIRECTION`：上一次被插入的记录、最后一个记录插入的防线、同一个方法插入的记录数，这些都是为了加速连续插入操作

- `PAGE_N_RECS`：用户的记录（不包括最大和最小记录）

- `PAGE_MAX_TRX_ID`：修改此数据页的当前最大事务id

- `PAGE_LEVEL`：索引页索引`id`

- `PAGE_INDEX_ID`：索引页的索引`ID`

- `PAGE_BTR_SEG_LEAF,PAGE_BTR_SEG_TOP`：叶子节点和非叶子节点的段头页地址

# 二：关键函数

## 2.1 fil_create_tablespace()

​	 创建表空间

```c++
dberr_t dict_build_tablespace(trx_t *trx, Tablespace *tablespace) {
  ...
  err = fil_ibd_create(space, tablespace->name(), datafile->filepath(),
                       tablespace->flags(), FIL_IBD_FILE_INITIAL_SIZE);
  ...
  // 初始化fsp header的其他字段
  bool ret = fsp_header_init(space, FIL_IBD_FILE_INITIAL_SIZE, &mtr, false);
  ...
}

static dberr_t fil_create_tablespace(space_id_t space_id, const char *name,
                                     const char *path, ulint flags,
                                     page_no_t size, fil_type_t type)
{
	...
    // 创建ibd文件
	file = os_file_create(
      	type == FIL_TYPE_TEMPORARY ? innodb_temp_file_key : innodb_data_file_key,
      	path, OS_FILE_CREATE | OS_FILE_ON_ERROR_NO_EXIT, OS_FILE_NORMAL,
      	OS_DATA_FILE, srv_read_only_mode && (type != FIL_TYPE_TEMPORARY),
      	&success);
    ...
    // 这里会将新创建的ibd文件填0以预分配空间
    // 调试显示size=7，即分配的空间为7*16KB，但os_file_set_size内会将其向上调整至8*16KB
    // buf2 = static_cast<byte *>(ut_malloc_nokey(buf_size + UNIV_PAGE_SIZE));
    success = os_file_set_size(path, file, 0, size * page_size.physical(),
                             srv_read_only_mode, true);
	...
    // 初始化fsp header pages，其中前3个page作用比较关键：
    // page 0: root page，也是fsp header page
    // page 1: ibuf_bitmap page，作用暂时不明
    // page 2: inode page，管理segment分配，每个inode entry对应一个segment
    buf2 = static_cast<byte *>(ut_malloc_nokey(3 * page_size.logical()));

  	page = static_cast<byte *>(ut_align(buf2, page_size.logical()));
  	memset(page, '\0', page_size.logical());
	
  	flags = fsp_flags_set_page_size(flags, page_size);
  	fsp_header_init_fields(page, space_id, flags);
  	mach_write_to_4(page + FIL_PAGE_ARCH_LOG_NO_OR_SPACE_ID, space_id);

  	mach_write_to_4(page + FIL_PAGE_SRV_VERSION, DD_SPACE_CURRENT_SRV_VERSION);
  	mach_write_to_4(page + FIL_PAGE_SPACE_VERSION, DD_SPACE_CURRENT_SPACE_VERSION);
	...
}
```

## 2.2 fseg_create_general()

创建segment

```c++
buf_block_t *fseg_create_general(
    space_id_t space_id, 
    page_no_t page,  // 调用者多传入0,表示需要分配一个新page作为segment header
    ulint byte_offset,   
    ibool has_done_reservation, 
    mtr_t *mtr)                 
{

  fil_space_t *space = fil_space_get(space_id);

  mtr_x_lock_space(space, mtr);
  const page_size_t page_size(space->flags);
  ...

  space_header = fsp_get_space_header(space_id, page_size, mtr);

  // 分配inode entry，代表该segment
  inode = fsp_alloc_seg_inode(space_header, mtr);

  // 从table space的page header中读取下一个要使用的segment id
  // 将其设置在inode entry的FSEG_ID字段中
  // 同时将刚刚已分配的segment id递增1并写回space的page header的FSP_SEG_ID字段
  seg_id = mach_read_from_8(space_header + FSP_SEG_ID);
  mlog_write_ull(space_header + FSP_SEG_ID, seg_id + 1, mtr);
  mlog_write_ull(inode + FSEG_ID, seg_id, mtr);
  mlog_write_ulint(inode + FSEG_NOT_FULL_N_USED, 0, MLOG_4BYTES, mtr);

  // 初始化inode中的各种extent链表
  flst_init(inode + FSEG_FREE, mtr);
  flst_init(inode + FSEG_NOT_FULL, mtr);
  flst_init(inode + FSEG_FULL, mtr);

  // 初始化segment的frag page数组为空(未分配任何page)
  mlog_write_ulint(inode + FSEG_MAGIC_N, FSEG_MAGIC_N_VALUE, MLOG_4BYTES, mtr);
  for (i = 0; i < FSEG_FRAG_ARR_N_SLOTS; i++) {
    fseg_set_nth_frag_page_no(inode, i, FIL_NULL, mtr);
  }

  // 且该page的类型是FIL_PAGE_TYPE_SYS
  // 该page是Change Buffer的header page，主要用于对ibuf btree的Page管理。
  if (page == 0) {
    block = fseg_alloc_free_page_low(space, page_size, inode, 0, FSP_UP,
                                     RW_SX_LATCH, mtr, mtr);

    header = byte_offset + buf_block_get_frame(block);
    mlog_write_ulint(buf_block_get_frame(block) + FIL_PAGE_TYPE,
                     FIL_PAGE_TYPE_SYS, MLOG_2BYTES, mtr);
  }

  // 初始化page header
  mlog_write_ulint(header + FSEG_HDR_OFFSET, page_offset(inode), MLOG_2BYTES,
                   mtr);
  mlog_write_ulint(header + FSEG_HDR_PAGE_NO,
                   page_get_page_no(page_align(inode)), MLOG_4BYTES, mtr);
  mlog_write_ulint(header + FSEG_HDR_SPACE, space_id, MLOG_4BYTES, mtr);
  ...
}

static fseg_inode_t *fsp_alloc_seg_inode(
    fsp_header_t *space_header,
    mtr_t *mtr)
{
  ...
  // 如果FSP_SEG_INODES_FREE链表为空
  // 该链表用于链接那些尚有inode空间可分配的inode_page
  // 如果该链表为空,那就要分配一个新的inode page了,这个过程我们在下面描述
  // 调用fsp_alloc_seg_inode_page创建一个新的inode page
  if (flst_get_len(space_header + FSP_SEG_INODES_FREE) == 0 &&
      !fsp_alloc_seg_inode_page(space_header, mtr)) {
    return (NULL);
  }
  
  ...
  // 从inode page中分配一个空闲inode
  const page_size_t page_size(mach_read_from_4(FSP_SPACE_FLAGS + space_header));
  const page_id_t page_id(
      page_get_space_id(page_align(space_header)),
      flst_get_first(space_header + FSP_SEG_INODES_FREE, mtr).page);

  block = buf_page_get(page_id, page_size, RW_SX_LATCH, mtr);
  page = buf_block_get_frame(block);

  // 遍历该inode page的所有inode entry
  // 如果发现某个Inode Entry的FSEG_ID字段未设置
  // 即认为该inode entry尚未分配
  n = fsp_seg_inode_page_find_free(page, 0, page_size, mtr);
  inode = fsp_seg_inode_page_get_nth_inode(page, n, page_size, mtr);

  // 如果由于本次分配导致该inode page内不再有可用的inode空间
  // 那需要将该inode page从space的FSP_SEG_INODES_FREE链表摘除并加入FSP_SEG_INODES_FULL链表尾部
  if (FIL_NULL == fsp_seg_inode_page_find_free(page, n + 1, page_size, mtr)) {
    flst_remove(space_header + FSP_SEG_INODES_FREE, page + FSEG_INODE_PAGE_NODE,
                mtr);
    flst_add_last(space_header + FSP_SEG_INODES_FULL,
                  page + FSEG_INODE_PAGE_NODE, mtr);
  }
  return (inode);
}
```

优先从table space的FSP_SEG_INODES_FREE链表中获取inode page并从中分配未使用的inode。

如果FSP_SEG_INODES_FREE链表为空，说明当前已无空闲的inode page，此时需分配新的inode page，参考函数*fsp_alloc_seg_inode_page*：

```c++
// 从space中分配一个未使用的inode page
static ibool fsp_alloc_seg_inode_page(
    fsp_header_t *space_header,
    mtr_t *mtr)
{
  space = page_get_space_id(page_align(space_header));
  const page_size_t page_size(mach_read_from_4(FSP_SPACE_FLAGS + space_header));

  // fsp_alloc_free_page这个函数比较有意思,值得仔细研究一番
  // 分配一个空闲page作为inode page
  block = fsp_alloc_free_page(space, page_size, 0, RW_SX_LATCH, mtr, mtr);
  page = buf_block_get_frame(block);
  // 设置新分配的PAGE类型为FIL_PAGE_INODE
  mlog_write_ulint(page + FIL_PAGE_TYPE, FIL_PAGE_INODE, MLOG_2BYTES, mtr);

  // 初始化inode page中的所有inode信息为空闲
  for (page_no_t i = 0; i < FSP_SEG_INODES_PER_PAGE(page_size); i++) {
    inode = fsp_seg_inode_page_get_nth_inode(page, i, page_size, mtr);
    mlog_write_ull(inode + FSEG_ID, 0, mtr);
  }
  // 将新分配的inode page加入至FSP_SEG_INODES_FREE链表的尾部
  flst_add_last(space_header + FSP_SEG_INODES_FREE, page + FSEG_INODE_PAGE_NODE, mtr);
  return (TRUE);
}
```

