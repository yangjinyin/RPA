# 1.提交流程

\1. 获取 MDL_key::COMMIT 锁: FTWRL会阻塞 commit 操作。
-------------------------------- **进入 prepare 阶段:**
\2. binlog prepare: 将上一次 commit 队列中的最大的 seq_no 写入本次事务的 last_commit 中。（用户发起的显式提交(显式commit), 或者DDL发起的隐式提交没有这一步）
\3. innodb prepare:
3.1 获取线程的 xid, 设置为事务的 xid.
3.2 修改Innodb中事务的状态为 Prepare 状态
3.3 将 undo 日志端从 active 设置为 prepare 状态, 并在undo段的第一个undo的last undo log header中写入xid.
-------------------------------- **进入 commit 阶段:**
\4. XID_Event生成并写入binlog cache中。会首先将事务中的写操作生成的event flush到binlog cache中, 再写入 xid event。这也符合binlog中事务event顺序。
\5. binlog flush:
5.1. 当前线程加入flush队列, 如果flush队列是空的, 则当前为leader; 如果为非空, 则为 follower, 非leader线程将被阻塞, 直到commit之后被leader线程唤醒, 完成提交。
5.2. 获取Lock log锁
5.3. 对flush队列进行fetch, 本次处理的队列就固定了
5.4. 在innodb存储引擎中flush redo log, 做 innodb层redo持久化
5.5. 为flush队列中每个事务生成gtid
5.6. 将flush队列中每个线程的binlog cache flush到 binlog文件中, 这里包含三步：
a. 直接将 GTID event 写入 binlog磁盘文件中
b. 将事务生成的别的 event 写入 binlog file cache中
c. 将 binlog cache[IO cache] flush到文件
5.7. 判断 binlog 是否需要切换, 设置切换标记。注意：这里是将事务的event写入binlog file cache后再判断, 因此一个事务的binlog都位于同一个binlog文件中
5.8. after_flush hook：如果**sync_binlog = 0**, 那么在这里更新 binlog 点位, 通知dump线程向从节点发送 event
\6. binlog sync:
6.1. 形成 sync 队列, 第一个进入 sync 队列的leader为本阶段的laeder, 其他flush队列加入sync队列的leader线程将被阻塞, 直到commit阶段被leader线程唤醒, finish_commit
6.2. 释放 Lock log mutex, 获取 Lock sync mutex
6.3. 根据 delay 的设置来决定是否延迟一段时间, 使得sync队列变大, last commit是在binlog prepare时生成, 这时last commit尚未修改, 因此加入sync队列的事务是同一组事务, 可以提高从库 mts 效率。
6.4. fetch sync队列, 对 sync 队列进行固化
6.5. sync binlog file到磁盘中, 需要根据sync_binlog的设置来决定是否刷盘
6.6. 如果 sync_binlog = 1, 那么更新 binlog end pos, 通知 dump线程发送 event，**binlog刷盘完成**
\7. commit阶段：
如果需要按顺序提交: order_commits:
7.1. sync队列加入commit队列, 第一个进入的 sync 队列的leader为本阶段的leader, 其他sync队列加入commit队列的leader会被阻塞, 直到 commit阶段后被leader线程唤醒, 进入 finish commit
7.2. 释放 Lock sync mutex，获取 lock commit mutex
7.3. fetch commit队列, 对 commit 队列进行固化
7.4. 调用 after_sync hook: 这里, 如果半同步复制为 after_sync, 则需要等待dump线程收到从节点对于commit队列中最大的binlog filename和 pos的ack。
7.5. 在 Innodb 层提交之前变更 last_commit, 将其变更为 commit 队列中最大的 seqno
7.6. COMMIT队列中每个事务按照顺序进行存储引擎层提交
7.7. 变更 gtid_executed
7.8. 释放 lock commit mutex
如果不需要按顺序提交:
8.1. 调用 after_sync hook: 这里, 如果半同步复制为 after_sync, 则需要等待dump线程收到从节点对于commit队列中最大的binlog filename和 pos的ack。
8.2. leader 线程唤醒组内成员, 进行各自操作

\9. 释放 m_stage_cond_binlog

9.1. commit 队列中事务清空 binlog cache 临时文件和内存
9.2. 如果不需要按顺序提交：则commit队列中线程各自进行存储引擎层的提交, 提交完成之后更新 gtid_executed
9.3. 决定是否进行 binlog 的 rotate
9.4. 如果 rotate 了 binlog, 则根据 expire_log_days 判断是否需要清理 binlog

# 2. 原理

  在开启binlog情况下，则有两个日志系统（server层的binlog日志 和 storage层的redolog日志）。mysql采用的内部xa 2阶段提交。其步骤如下：

1. **Prepare 阶段：**InnoDB 将回滚段设置为 prepare 状态；将 redolog 写文件并刷盘；（8.0版本已经将redolog刷盘放到commit阶段中的flush阶段中了，组刷盘）
2. **Commit 阶段：**Binlog 写入文件；binlog 刷盘；InnoDB commit；

 两阶段提交保证了事务在多个引擎和 binlog 之间的原子性，以 binlog 写入成功作为事务提交的标志，而 InnoDB 的 commit 标志并不是事务成功与否的标志。

 在崩溃恢复中，是以 binlog 中的 xid 和 redolog 中的 xid 进行比较，xid 在 binlog 里存在则提交，不存在则回滚。我们来看崩溃恢复时具体的情况：

1. 在 prepare 阶段崩溃，即已经写入 redolog，在写入 binlog 之前崩溃，则会回滚；
2. 在 commit 阶段，当没有成功写入 binlog 时崩溃，也会回滚；
3. 如果已经写入 binlog，在写入 InnoDB commit 标志时崩溃，则重新写入 commit 标志，完成提交。



trx_sys_get_next_trx_id_or_no: 最大事务号

# 3. 函数分析

```c++
|--ha_commit_trans() // 该函数负责处理 binlog 层和存储引擎层的提交
|		|--1. 先获取MDL_KEY锁
|		|--2. 判断是否开启xa事务，如果开启，则在引擎层生成一个xa事务，并执行2pc
|		|--3. MYSQL_BIN_LOG::prepare()//prepare 阶段不将事务的 prepare record 刷到 innodb redo log
|		|		|--ha_prepare_low()            //在引擎层prepare，包括innodb引擎和binlog引擎
|		|		|		|--binlog_prepare() //binglog引擎prepare
|		|		|		|		|--thd->get_transaction()->store_commit_parent() //将上一次commit队列中最大的 seq num 写入本次事务的 last_commit 中
|		|		|		|		|		|--innobase_xa_prepare() //innobase层prepare一个xa事务
|		|		|		|		|		|		|--trx_prepare_for_mysql（）//undo段prepare
|		|		|		|		|		|		|		|--trx_prepare_low()
|		|		|		|		|		|		|		|		|--trx_undo_set_state_at_prepare() //undolog状态从设置为TRX_UNDO_PREPARED
|		|		|		|		|		|		|		|		|		|--trx_undo_page_get() // 获得 undo page
|		|		|		|		|		|		|		|		|		|--trx_undo_write_xid() // 向undo header写XID信息
|		|--4. xid_state->set_state(XID_STATE::XA_PREPARED); //设置 XA 事务状态为 XA_PREPARED 状态
|		|--5. MYSQL_BIN_LOG::commit()  //将在二进制日志和存储引擎上提交
|		|		|--MYSQL_BIN_LOG::write_xa_to_cache() //i.XID_Event生成并写入binlog cache中 (cache_mngr对象中)
|		|		|--MYSQL_BIN_LOG::ordered_commit() //分成3个stage来顺序并发提交
|		|		|		|--stage 0：确保备机slave线程按照relaylog日志顺序回放提交		
|		|		|		|--stage 1： 将事务 flush 到二进制日志                                                               
|		|		|		|		|--change_stage(BINLOG_FLUSH_STAGE) //第一个进入flush队列的为leader, 非leader线程将被阻塞, 直到 commit 阶段被 leader 线程唤醒                                                             
|		|		|		|		|-- MYSQL_BIN_LOG::process_flush_stage_queue() //处理flush队列
|		|		|		|		|		|--fetch_and_process_flush_stage_queue
|		|		|		|		|		|		|--a. fetch_queue_for() //获取整个 flush 队列并清空flush队列, 对 flush 队列进行固化
|		|		|		|		|		|		|--b. ha_flush_logs()  //flush redo log
|		|		|		|		|		|		|		|--innobase_flush_logs()//flush阶段&&innodb_flush_log_at_trx_commit=1则进行 flush
|		|		|		|		|		|		|		|		|--log_buffer_flush_to_disk() //将redo log buffer sync到磁盘中
|		|		|		|		|		|		|--c.assign_automatic_gtids_to_flush_group()  //为 flush 队列中每个事务生成 gtid
|		|		|		|		|		|		|--d.MYSQL_BIN_LOG::flush_thread_caches()  //将线程的 binlog cache 刷新到 binlog 日志文件,先写入gtid event，然后再写入其他event
|		|		|		|		|		|		|		|--flush() //将stmt_cache 和 trx_cache flush到binary log中
|		|		|		|		|		|		|		|		|--binlog_cache_data::flush()
|		|		|		|		|--e. MYSQL_BIN_LOG::flush_cache_to_file() //Flush binary log I/O cache到binlog文件
|		|		|		|		|--f. MYSQL_BIN_LOG::update_binlog_end_pos()//更新binlog end pos 点位, 通知 dump 线程发送 binlog
|		|		|		|--stage 2:change_stage(SYNC_STAGE)//binlog 刷盘        
|		|		|		|		|--fetch_queue_acquire_lock()  //取出m_queue[1]中 thd信息
|		|		|		|		|--MYSQL_BIN_LOG::sync_binlog_file() //如果在flush阶段，并没有完全把缓冲区flush到磁盘中，fsync
|		|		|		|		|		|--mysql_file_sync()
|		|		|		|		|		|		|--my_sync()
|		|		|		|--stage 3:   change_stage(COMMIT_STAGE)
|		|		|		|		|--call_after_sync_hook()//如果rpl_semi_sync_master_wait_point的值设置为after_sync等ack
|		|		|		|		|		|--ReplSemiSyncMaster::commitTrx()//半同步的回掉函数
|		|		|		|		|--MYSQL_BIN_LOG::process_commit_stage_queue()  //遍历commit队列中的每一个线程，然后在存储引擎层提交
|		|		|		|		|--finish_transaction_in_engines()
|		|		|		|		|		|--ha_commit_low()  //在各个引擎上提交（主要是binlog 和innodb)  
|		|		|		|		|		|		|--binlog_commit()  // nothing to do
|		|		|		|		|		|		|--innobase_commit() //innobase 引擎层提交
|		|		|		|		|		|		|		|--trx_commit_for_mysql() 
|		|		|		|		|		|		|		|		|--rx_undo_gtid_add_update_undo()//gtid持久化，更新undo
|		|		|		|		|		|		|		|		|--trx_update_mod_tables_timestamp() //更新dict_table_t::update_time时间
|		|		|		|		|		|		|		|		|--trx_commit_low()                                                         |		|		|		|		|		|		|		|		|		|--trx_set_cts_low() //回写cts
|		|		|		|		|		|		|		|		|		|--trx_write_serialisation_history() //更新的undo日志记录写入分配的回滚段
|		|		|		|		|		|		|		|		|		|		|--trx_undo_set_state_at_finish()//设置事务undo state=TRX_UNDO_CACHED
|		|		|		|		|		|		|		|		|		|--trx_commit_in_memory() 
|		|		|		|		|		|		|		|		|		|		|--trx_release_impl_and_expl_locks()//将当前事务id从活跃事务id列表中删除 
|		|		|		|		|		|		|		|		|		|		|--trx_erase_from_serialisation_list_low() //把trx从seri-list删除
|		|		|		|		|		|		|		|--trx_deregister_from_2pc()
|		|		|		|		|		|		|		|--trx_commit_complete_for_mysql()  //将事务的信息刷盘
|		|		|		|		|--gtid_state->update_commit_group()   //更新 gtid_executed             
|		|		|		|		|--signal_done(final_queue); //释放 m_stage_cond_binlog 唤醒非leader线程
|		|		|		|		|-- MYSQL_BIN_LOG::finish_commit()
```

# 4.核心结构体

***trx_t:\*** 整个结构体每个连接持有一个，也就是在创建连接后执行第一个事务开始，整个结构体就被初始化了，后续这个连接的所有事务一直复用里面的数据结构，直到这个连接断开。同时，事务启动后，就会把这个结构体加入到全局事务链表中(`trx_sys->mysql_trx_list`)，如果是读写事务，还会加入到全局读写事务链表中(`trx_sys->rw_trx_list`)。在事务提交的时候，还会加入到全局提交事务链表中(`trx_sys->trx_serial_list`)。state字段记录了事务四种状态:`TRX_STATE_NOT_STARTED`, `TRX_STATE_ACTIVE`, `TRX_STATE_PREPARED`, `TRX_STATE_COMMITTED_IN_MEMORY`。 这里有两个字段值得区分一下，分别是id和no字段。id是在事务刚创建的时候分配的(只读事务永远为0，读写事务通过一个全局id产生器产生，非0)，目的就是为了区分不同的事务(只读事务通过指针地址来区分)，而no字段是在事务提交前，通过同一个全局id生产器产生的，主要目的是为了确定事务提交的顺序，保证加入到`history list`中的update undo有序，方便purge线程清理。 此外，trx_t结构体中还有自己的read_view用来表示当前事务的可见范围。分配的insert undo slot和update undo slot。如果是只读事务，read_only也会被标记为true。

***trx_sys_t:\*** 这个结构体用来维护系统的事务信息，全局只有一个，在数据库启动的时候初始化。比较重要的字段有：max_trx_id，这个字段表示系统当前还未分配的最小事务id，如果有一个新的事务，直接把这个值作为新事务的id，然后这个字段递增即可。descriptors，这个是一个数组，里面存放着当前所有活跃的读写事务id，当需要开启一个readview的时候，就从这个字段里面拷贝一份，用来判断记录的对事务的可见性。rw_trx_list，这个主要是用来存放当前系统的所有读写事务，包括活跃的和已经提交的事务。按照事务id排序，此外，奔溃恢复后产生的事务和系统的事务也放在上面。mysql_trx_list，这里面存放所有用户创建的事务，系统的事务和奔溃恢复后的事务不会在这个链表上，但是这个链表上可能会有还没开始的用户事务。trx_serial_list，按照事务no(trx_t->no)排序的已经提交的事务。rseg_array，这个指向系统所有可以用的回滚段(`undo segments`)，当某个事务需要回滚段的时候，就从这里分配。rseg_history_len， 所有提交事务的update undo的长度，也就是上文提到的历史链表的长度，具体的update undo链表是存放在这个undo log中以文件指针的形式管理起来。view_list，这个是系统当前所有的readview, 所有开启的readview的事务都会把自己的readview放在这个上面，按照事务no排序。

***trx_purge_t:\*** Purge线程使用的结构体，全局只有一个，在系统启动的时候初始化。view，是一个readview，Purge线程不会尝试删除所有大于view->low_limit_no的undolog。limit，所有小于这个值的undolog都可以被truncate掉，因为标记的日志已经被删除且不需要用他们构建之前的历史版本。此外，还有rseg，page_no, offset，hdr_page_no, hdr_offset这些字段，主要用来保存最后一个还未被purge的undolog。

***read_view_t:\*** InnDB为了判断某条记录是否对当前事务可见，需要对此记录进行可见性判断，这个结构体就是用来辅助判断的。每个连接都的trx_t里面都有一个readview，在事务需要一致性的读时候(不同隔离级别不同)，会被初始化，在读结束的时候会释放(缓存)。low_limit_no，这个主要是给purge线程用，readview创建的时候，会把当前最小的提交事务id赋值给low_limit_no，这样Purge线程就可以把所有已经提交的事务的undo日志给删除。low_limit_id, 所有大于等于此值的记录都不应该被此readview看到，可以理解为high water mark。up_limit_id, 所有小于此值的记录都应该被此readview看到，可以理解为low water mark。descriptors, 这是一个数组，里面存了readview创建时候所有全局读写事务的id，除了事务自己做的变更外，此readview应该看不到descriptors中事务所做的变更。view_list，每个readview都会被加入到trx_sys中的全局readview链表中。

***trx_id_t:\*** 每个读写事务都会通过全局id产生器产生一个id，只读事务的事务id为0，只有当其切换为读写事务时候再分配事务id。为了保证在任何情况下(包括数据库不断异常恢复)，事务id都不重复，InnoDB的全局id产生器每分配256(`TRX_SYS_TRX_ID_WRITE_MARGIN`)个事务id，就会把当前的max_trx_id持久化到ibdata的系统页上面。此外，每次数据库重启，都从系统页上读取，然后加上256(`TRX_SYS_TRX_ID_WRITE_MARGIN`)。

***trx_rseg_t:\*** undo segment内存中的结构体。每个undo segment都对应一个。update_undo_list表示已经被分配出去的正在使用的update undo链表，insert_undo_list表示已经被分配出去的正在使用的insert undo链表。update_undo_cached和insert_undo_cached表示缓存起来的undo链表，主要为了快速使用。last_page_no, last_offset, last_trx_no, last_del_marks表示这个undo segment中最后没有被Purge的undolog。



