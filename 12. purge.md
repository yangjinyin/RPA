# 参数

```c++
innodb_purge_batch_size(300):  用来设置每次purge操作需要清理的undo page数量
innodb_max_purge_log(0): 用来控制history list的长度，若大于该参数时，其会延缓DML的操作
innodb_max_purge_lag_delay(0): 用来控制DML操作每行数据的最大延缓时间，单位为毫秒
innodb_purge_threads(4): 用来purge线程数
```



# 流程

## Coordinator thread

1. 获取最老的oldest视图用来清理
2. 收集undo记录
3. 创建worker线程进行清理
4. 清理undo segment

```c++
|-->srv_start_purge_threads()
|		|-->srv_purge_coordinator_thread() //主入口函数
|		|		|-->//循环执行，直至满足退出条件
|		|		|-->srv_do_purge() //执行清理任务
|		|		|		|-->n_use_threads //根据history list调整purge work线程数
|		|		|		|-->trx_purge() //purge一批次 undolog
|		|		|		|		|-->1. clone_oldest_view(&purge_sys->view) //获取最老的视图用于清理
|		|		|		|		|-->2. trx_purge_attach_undo_recs() //收集需要清除的UNDO记录并分给各个purge线程
|		|		|		|		|		|-->purge_sys->query->thrs //遍历,每个个线程有自己的purge_node_t节点
|		|		|		|		|		|-->trx_purge_fetch_next_rec() //收集足够多的unod-log,并加入到purge_groups中
|		|		|		|		|		|		|-->trx_purge_choose_next_log()//选择一个undo log文件来进行purge
|		|		|		|		|		|		|		|-->trx_purge_read_undo_rec()//purge_sys->rseg不为null意味着有rollback段
|		|		|		|		|		|		|		|		|-->2.1 //初始化page_no & page_offset
|		|		|		|		|		|		|		|		|-->2.2 purge_sys->rseg->last_del_marks//判断是否有删除标志
|		|		|		|		|		|		|		|		|-->2.3 trx_undo_get_first_rec() //获取这个page的第一条记录
|		|		|		|		|		|		|		|		|		|-->2.3.1 trx_undo_page_get() //先根据page_no获取具体的page
|		|		|		|		|		|		|		|		|		|-->2.3.2 mach_read_from_8(undo_header + TRX_UNDO_TRX_ID)//修改事务id
|		|		|		|		|		|		|		|		|		|-->2.3.3 trx_undo_page_get_first_rec()//在具体page上获取第一条rec
|		|		|		|		|		|		|		|		|		|		|-->trx_undo_page_get_start()//获取undo的start位置
|		|		|		|		|		|		|		|		|		|		|-->trx_undo_page_get_end() //获取end的位置 
|		|		|		|		|		|		|		|		|		|-->2.3.4 trx_undo_get_next_rec_from_next_page()//当前page没有rec，取下一个 
|		|		|		|		|		|		|		|		|-->2.4 //设置purge的page_no,offset,undo_no,space_id  
|		|		|		|		|		|		|-->//检查是否超出视图的最小值purge_sys->view.low_limit_no()
|		|		|		|		|		|		|-->trx_undo_build_roll_ptr() //构造回滚指针
|		|		|		|		|		|		|-->trx_purge_get_next_rec() //获取下一条rec
|		|		|		|		|		|		|		|-->trx_undo_page_get_s_latched()//获取当前undo的页面
|		|		|		|		|		|		|		|-->trx_undo_page_get_next_rec() //在当前页面查找下一条需要purge的记录 
|		|		|		|		|		|		|		|-->trx_undo_rec_get_type()//检查记录类型是否需要purge 
|		|		|		|		|-->3. que_fork_scheduler_round_robin()//提交任务到工作队列
|		|		|		|		|-->4. trx_purge_wait_for_workers_to_complete()//等待所有的work线程完成
|		|		|		|		|-->5. trx_purge_truncate()//清理回滚段，所以得在二级索引清理后再清理
|		|		|		|		|		|-->5.1 trx_purge_truncate_history() //清理回history_list
|		|		|		|		|		|		|-->5.1.1 trx_purge_truncate_rseg_history()//purge undo 表空间
|		|		|		|		|		|		|		|-->trx_undo_page_get() //获取undo_page
|		|		|		|		|		|		|		|-->trx_undo_truncate_start()//清理undo-log head
|		|		|		|		|		|		|		|-->trx_purge_free_segment()//清理rollback segment    
|		|		|		|		|		|		|		|-->trx_rsegf_get()//获取新的rollback ptr
|		|		|		|		|		|		|-->5.1.2 trx_purge_truncate_rseg_history()//清理system 表空间
|		|		|		|		|		|		|-->5.1.3 trx_purge_truncate_rseg_history()//清理temporary 表空间
|		|		|		|		|		|-->5.2 trx_purge_truncate_undo_spaces() //truncate undo space
```

## Worker thread

```c++
|-->srv_worker_thread()
|		|-->srv_task_execute() //执行任务
...
|		|		|-->rec = node->recs->front();//获取要处理的purge_rec
|		|		|-->row_purge()//purge
|		|		|		|-->row_purge_parse_undo_rec()//解析purge_rec
|		|		|		|-->row_purge_record()
|		|		|		|		|-->case: row_purge_del_mark() //TRX_UNDO_DEL_MARK_REC
|		|		|		|		|		|-->row_purge_remove_sec_if_poss()//依次清理二级索引
|		|		|		|		|		|		|-->row_purge_remove_sec_if_poss_leaf()//乐观清理
|		|		|		|		|		|		|		|-->row_search_index_entry()//先找到entry
|		|		|		|		|		|		|		|-->btr_cur_optimistic_delete()//乐观删除
|		|		|		|		|		|		|-->row_purge_remove_sec_if_poss_tree()//悲观删除
|		|		|		|		|		|		|		|-->row_search_index_entry()//先找到entry
|		|		|		|		|		|		|		|-->btr_cur_pessimistic_delete()
|		|		|		|		|		|-->row_purge_remove_clust_if_poss()//最后清理主键索引
|		|		|		|		|-->case:row_purge_upd_exist_or_extern_func()//UPDATE场景
|		|		|		|		|		|-->row_build_index_entry_low()//构建老的版本
|		|		|		|		|		|-->row_purge_remove_sec_if_poss()//同上
|		|-->srv_wake_purge_thread_if_not_active()//如果没有任务，则唤醒coordinator线程
```

