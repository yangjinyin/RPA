# 一 整体架构

 ![优化器代码架构图](http://mysql.taobao.org/monthly/pic/202412/yuanqi_pic/optimizer_code_arch.png)

可以把优化工作分成两块：

1. `Query_block::prepare()`，主要完成了Resolver和Logical Transformations的工作。对应prepare-execute语句中的prepare阶段。

2. `JOIN::optimize()`主要完成了CBO优化，生成物理执行计划等工作。

```c++
Sql_cmd_dml::execute() 
|-->Sql_cmd_dml::prepare() //prepare阶段，主要完成了Resolver和Logical Transformations的工作
|		|-->Sql_cmd_select::prepare_inner() //根据不同类型就调用不同函数
|		|		|-->//此处拿select做例子.如果表达式中没有 UNION/INTERSECT/EXCEPT 或者多层级的order，那么就认为其是简单的block
|		|		|-->1. Query_block::prepare() //解析表和列信息。对抽象语法树应用永久性转换，如半连接转换、派生表转换、常量值和冗余子句（例如 ORDER BY、GROUP BY）的消除。
|		|		|		|-->1.1 propagate_nullability() //主要设置table中nullable值
|		|		|		|-->1.2 setup_tables()					//主要设置table_ref中的next_leaf
|		|		|		|-->1.3 Query_block::resolve_placeholder_tables() //对派生表处理
|		|		|		|-->1.4 Query_block::setup_wild() //解析*
|		|		|		|-->1.5 Query_block::setup_base_ref_items() //初始化base_ref_items
|		|		|		|-->1.6 setup_fields() //主要是fix fields
|		|		|		|-->1.7 Query_block::setup_conds() //解析where 和join 条件
|		|		|		|-->1.8 Query_block::setup_group() //解析group_by
|		|		|		|-->1.9 m_having_cond->fix_fields() //解析having
|		|		|		|-->1.10 Query_block::resolve_rollup（）//解析rollup
|		|		|		|-->1.11 setup_order() //解析order by
|		|		|		|-->1.12 Query_block::resolve_subquery() //解析子查询
|		|		|		|-->1.13 Query_block::transform_scalar_subqueries_to_join_with_derived() //标量子查询转换为派生表
|		|		|		|-->1.14 Query_block::flatten_subquerie() //扁平化子查询
|		|		|		|-->1.15 Query_block::apply_local_transforms() //当前查询快转换
|		|		|		|-->1.16 Window::eliminate_unused_objects() //消除没有用到的窗口函数
|		|		|-->set_prepared()//prepare完成标记
|------------------------------------------------------------------------------------------------------------
|-->Sql_cmd_dml::execute_inner()
|		|-->Query_expression::optimize() //对每个query_block进行物理优化
|		|		|-->Query_expression::set_limit() //limit = limit+offset  
|		|		|-->Query_block::optimize() //物理优化
|		|		|		|-->JOIN::optimize()
|		|		|		|		|-->2.1 count_field_types() //统计临时表中fields信息
|		|		|		|		|-->2.2 Query_block::get_optimizable_conditions() //拷贝query_block中having where到join中
|		|		|		|		|-->2.3 //预处理rollup场景，拷贝query_block中rollup_item
|		|		|		|		|-->2.4 //如果有派生表或视图则进行优化 query_block->leaf_tables->is_view_or_derived()
|		|		|		|		|		|-->Table_ref::optimize_derived() //派生表视图优化
|		|		|		|		|		|		|-->Query_expression::optimize()//递归 表结构中Query_expression优化
|		|		|		|		|		|		|-->Table_ref::create_materialized_table() //const 表进行物化
|		|		|		|		|		|		|		|-->instantiate_tmp_table() //创建临时表  
|		|		|		|		|-->2.5 JOIN::create_access_paths_for_zero_rows() //select_limit_cnt=0场景优化
|		|		|		|		|		|-->NewZeroRowsAccessPath()
|		|		|		|		|-->2.6 optimize_cond() //where条件优化 
|		|		|		|		|		|-->2.6.1 build_equal_items()//构建等值传播
|		|		|		|		|		|-->2.6.2 propagate_cond_constants() //常数传播
|		|		|		|		|		|-->2.6.3 remove_eq_conds() //移除const and equal item
|		|		|		|		|-->2.7 optimize_cond() //having条件优化
|		|		|		|		|-->2.8 JOIN::prune_table_partitions() //分区裁剪
|		|		|		|		|		|-->prune_partitions()
|		|		|		|		|-->2.9 optimize_aggregated_query() //聚合函数COUNT()、MIN()、MAX()对应的值，替换成常量
|		|		|		|		|-->2.10 substitute_gc() //将生成列代替having or where中条件
|		|		|		|		|-------------------------------------------------------------------------------------------
|		|		|		|		|-->2.11 JOIN::make_join_plan() //生成最佳访问路径
|		|		|		|		|		|-->2.11.1 JOIN::init_planner_arrays() //初始化相关变量
|		|		|		|		|		|-->2.11.2 JOIN::propagate_dependencies() //依赖性传播
|		|		|		|		|		|-->2.11.3 update_ref_and_keys() //更新join_table中m_keyuse
|		|		|		|		|		|-->2.11.4 pull_out_semijoin_tables() //半连接一定条件下转换成inner join
|		|		|		|		|		|-->2.11.5 JOIN::extract_const_tables() //const表，如果是，join_read_const_table()进行读取
|		|		|		|		|		|-->2.11.6 JOIN::extract_func_dependent_tables()//会判断一个表是否函数性依赖一个常量，是则读取
|		|		|		|		|		|-->2.11.7 JOIN::update_sargable_from_const() //const表读取后，更新sargable中内容
|		|		|		|		|		|-->2.11.8 JOIN::estimate_rowcount() //每张表估算行数
|		|		|		|		|		|-->2.11.9 JOIN::optimize_keyuse() //计算keyuse中ref_table_rows值
|		|		|		|		|		|-->2.11.10 optimize_semijoin_nests_for_materialization()//semijoin采取物化策略时的order
|		|		|		|		|		|-->2.11.11 Optimize_table_order::choose_table_order() //选择table 顺序
|		|		|		|		|		|		|-->Optimize_table_order::optimize_straight_join() //如果有hint指定了连接顺序，则直接生成
|		|		|		|		|		|		|-->Optimize_table_order::greedy_search() //贪心搜索来寻得最小的连接代价
|		|		|		|		|		|		|		|-->Optimize_table_order::best_extension_by_limited_search() ////穷举搜索
|		|		|		|		|		|-->2.11.12 JOIN::decide_subquery_strategy()//决定子查询的策略
|		|		|		|		|		|-->2.11.13 JOIN::get_best_combination()//根据join order设置join_tables,best_ref,best_pos
|		|		|		|		|		|-->2.11.14 JOIN::finalize_derived_keys()//删除派生表不需要的key
|		|		|		|		|--//该函数结束后，确定所有表的AccessPath以及他们的Join order,还缺GROUP/ORDER/DISTINCT/WINDOWS信息
|		|		|		|		|------------------------------------------------------------------------------------------
|		|		|		|		|-->2.12 substitute_for_best_equal_field()//利用2.6.1中的等值类来应用，消除所有多重相等谓词
|		|		|		|		|-->2.13 JOIN::init_ref_access() //当表的方式方式是ref时 则初始化table access信息
|		|		|		|		|		|-->create_ref_for_key() //ref table创建Index_lookup结构体(m_ref)，记录了用于ref的完整信息
|		|		|		|		|-->2.14 make_join_query_block()
|		|		|		|		|		|-->make_cond_for_table() //每个表添加条件，这个条件是当从这个表读完数据后能立刻check的
|		|		|		|		|		|-->test_if_cheaper_ordering()//recheck 考虑索引，特定条件下需要调整索引
|		|		|		|		|-->2.15 JOIN::optimize_distinct_group_order()//对group by，order by，distinct优化
|		|		|		|		|		|-->test_if_skip_sort_order() //使用索引跳过order by
|		|		|		|		|		|		|-->test_quick_select()
|		|		|		|		|		|-->create_order_from_distinct() //使用group by(order by) 来替代distinct
|		|		|		|		|-->2.16 need_tmp_before_win = true//判断窗函数前是否需要创建临时表
|		|		|		|		|-->2.17 JOIN::alloc_qep() //为best_ref中的每个JOIN_TAB都创建一个QEP_TAB对象
|		|		|		|		|-->2.18 JOIN::test_skip_sort() //使用索引跳过order by
|		|		|		|		|-->2.19 JOIN::finalize_table_conditions()//最终确定每个表的condition，并且做去除冗余和常量缓存
|		|		|		|		|-->2.20 make_join_readinfo() //执行前设置一些必要信息
|		|		|		|		|		|-->2.20.1 setup_semijoin_dups_elimination() //设置semi-join的必要信息
|		|		|		|		|		|-->2.20.2 QEP_TAB::init_join_cache() //设置join cache(bnl/bka)
|		|		|		|		|		|-->2.20.3 QEP_TAB::push_index_cond() //谓词下推
|		|		|		|		|		|		|-->make_cond_for_index()//满足一系列条件后 创建下推cond item
|		|		|		|		|		|		|-->ha_innobase::idx_cond_push()//innodb层ICP接口调用
|		|		|		|		|-->2.21 JOIN::make_tmp_tables_info() //设置临时表信息，并且将其加入到QEP_TAB数组的合适位置
|		|		|		|		|-->2.22 JOIN::create_access_paths() //生成accessPath
|		|		|-->set_optimized()//设置optimize标记
|		|		|-->CreateIteratorFromAccessPath() //创建迭代器
|---------------------------------------------------------------------------------------------------------
|		|-->Query_expression::execute() //对每个quer_block进行执行
|		|		|-->Query_expression::ExecuteIteratorQuery()
|		|		|		|-->3.1 THD_STAGE_INFO()           //设置线程的状态为executing
|		|		|		|-->3.2 ClearForExecution()        //清理之前的迭代器数据
|		|		|		|-->3.3 query_result->start_execution(thd) //设置为执行状态
|		|		|		|-->3.4 send_result_set_metadata()  //先把元数据发送给客户端(m_protocol...)
|		|		|		|-->3.5 m_root_iterator->Init()         //调用不同的init迭代器。此处我们拿hashjoin迭代器举例
|		|		|		|		|-->HashJoinIterator::Init()....
|		|		|		|-->//enter loop 读一行并发送
|		|		|		|-->3.6 m_root_iterator->Read() //调用不同read的迭代器
|		|		|		|-->3.7 query_result->send_data() //发送数据
```

#

# 二 preapre阶段

## Table_ref

Table_ref最好理解，就是一条SQL中被解析为表的部分，只不过需要注意的是，`Table_ref`指的不一定是base table，也有可能是derived table，nested-join等在SQL中一切可以理解为一个表的结构。

```
class Table_ref {
  Table_ref *next_local //某一层 SELECT 的 FROM 中表的链表指针
  const char *db
  const char *table_name

  Item *m_join_cond // JOIN 条件
  List<String> *join_using_fields //JOIN ...USING 对应 USING 子句宏的 field 名称列表
  /*嵌套连接
    1.代表外连接中的内部表(inner tables); 
    2.代表内连接中括号内的表(resolve时被消除); 
    3.代表派生表或视图中引用的表; 
    4.代表semi-join嵌套中的表; 
    5.代表子查询中的表;
  */
  NESTED_JOIN *nested_join 
  Table_ref *embedding //
  mem_root_deque<Table_ref *> *join_list //
  
  Table_ref *next_leaf{nullptr};				//同一层的表 做叶子表
  Item *derived_where_cond{nullptr};   ///< where条件中的派生表
}
```



## Item

`Item`代表了一条SQL中被解析为表达式的部分，yacc解析将条件表达式解析成一颗Item树。在contextualize阶段时，会对这些PTI_item进行itemize，将它们从解析树节点转化成真正意义的表达式树节点。http://www.orczhou.com/wp-content/uploads/2012/11/classItem__inherit__graph.png



## Query_block

一个查询块对应着一条基本的 SELECT 语句的语法结构

```c++
class Query_block {
  Query_expression *master{nullptr}; //上一层查询块
  Query_expression *slave{nullptr};  //指向属于该查询表达式的第一个查询块
  Query_block *next{nullptr};			//指向同级的下一个block的
  
  SQL_I_List<Table_ref> m_table_list // FROM 字句中的所有表列表，使用 Table_ref::next_local 进行遍历
  SQL_I_List<ORDER> order_list //ORDER BY 子句字段列表
  QL_I_List<ORDER> group_list //GROUP BY 子句字段列表
  table_map outer_join //outer join 查询中所有 inner tables 的 bitmap
  mem_root_deque<Table_ref *> sj_nests // semi-join 的表 nests 列表

  mem_root_deque<Item *> fields // join 和 filtering 之后所需的 fields，包括 select list(project所需字段)、group by list(分组所需字段)、having clause(having字句字段)、window clause(窗口函数字段)、order by clause(order by字段)
  Item *select_limit // LIMIT 子句
  Item *offset_limit // LIMIT .. OFFSET 子句
  Item *m_where_cond // WHERE 子句
  Item *m_having_cond // HAVING 子句
}
```

## Query_expression

`Query_expression`代表了由一组Query_block通过集合操作形成的语句，这里的集合操作有UNION，INTERSECT，EXCEPT三种。



## 2.1 传递null到join的内表列表

propagate_nullability(): 当一个表可能包含全为NULL的行时，这个表被称为nullable。当一个表是OUTER JOIN的内表时，会将这个表标记为nullable，并且向内传递。主要用来防止一些不应该的优化。比如outer join不能优化成 inner join。



## 2.2 解析设置查询块的leave_tables

setup_tables(): 该函数的作用就是构建leaf_tables，包括base tables和derived tables列表，用于后续的优化。setup_tables并不会递归调用，而是只解决本层的tables，并统计出本层derived table的个数。



## 2.3 解析处理派生表

resolve_placeholder_tables(): 将派生表/视图合并到上层查询，不能合并的派生表做物化处理。

```
select dt.a , t2.c from (select a, b from t1 where cond1) dt join t2 on t1.a = t2.c where cond2;
->select dt.a , t2.c from t1 join t2 on t1.a = t2.c where cond1 and cond2;
```

### 场景限制

1）派生表中含有聚合函数，或者含有DISTINCT、GROUP BY、HAVING这些分组子句

2）派生表中有 UNION或UNION ALL

3）视图，创建时已经指定ALGORITHM=TEMPTABLE

4）派生表中含LIMIT子句，因为合并会导致结果集改变  select * from (select id,c1 from t1 limit 10) a where a. id=1;

5）派生表的SELECT列表中有子查询，也就是标量子查询

...

### 优化过程

```
|-->Query_block::resolve_placeholder_tables()
|			|-->Query_block::merge_derived()			//合并派生表的主函数
|			|			|-->Table_ref::merge_underlying_tables() //先处理派生表
|			|			|			|-->//把派生表中的所有表加到父节点的next_leaf中，同时更新父查询中的各种count信息
|			|			|			|-->Table_ref::merge_where() //把派生表中的where条件merge父查询中
|			|			|			|-->Table_ref::create_field_translation() //建立对derived table需要获取的列的引用
|			|			|			|-->Query_expression::exclude_level() //移除派生表的query_block
|			|			|			|-->fix_tables_after_pullout() //更新表的信息
|			|			|			|-->Table_ref::setup_materialized_derived() //不满足要求的派生表，这设置为物化临时表
```

处理逻辑

1. 先做一些条件判断是否满足派生表合并的条件
2. 把derived table表（dt）merge到当前query_block中m_table_nest（derived_table->merge_underlying_tables())，此成员类记录nest join的表信息。 就是上图例子中
3. derived table中的所有表（t1）连接到父查询的table_list列表中，同时把derived table从父查询中删除
4. 把派生表中的where条件merge父查询中  set_join_cond(and_conds(join_cond(),derived_query_expression()->first_query_block()->where_cond()))
5. 建立对derived table需要获取的列的引用，主要实现是把派生表的列保存到父table的field_translation 成员变量中
6. 将derived table结构从父查询中删除，主要是query_block移除
7. 更新表的连接信息，位置信息
8. 一种特定条件下的order by 也是允许 合并的。（如果父查询允许排序并且正好是只有derived table，且没有union条件，group by 等聚合函数）



## 2.4 解析*符号

通过调用`Query_block::setup_wild()`函数完成，遍历fields，如果该fields是一个*符号，则将其展开



## 2.5  建立Query_block级别的base_ref_items

通过调用`setup_base_ref_items()`完成，该函数初始化了Ref_item_array base_ref_items对象，该对象可以理解为一个Item *类型的数组。方便查询块的其他Item可以进行引用，例如子查询的引用（Item_view_ref）、聚合函数引用（Item_aggregate_ref）、外查询列的引用（Item_outer_ref）等



## 2.6 setup_fields

所有fields与数据库的列元信息进行绑定，绑定通过调用`fix_fields()`实现。简单来说，**`set_fields`函数将表字段`Field`对象的属性和元数据复制到`Item_field`对象**，从而可以反映字段在表中的定义，比如说列名，列类型，列字符集和其他的属性。

`fix_fields`函数通过`find_field_in_table`搜索特定表中的`Field`字段。通过`TABLE_SHARE`对象的`HASH name_hash`哈希字段并结合缓存机制来提升字段查询效率

```c++
//系统函数调用
|-->setup_fields()
|			|-->Item_str_func::fix_fields() //不同的item 调用不同的fix_fields方法。此处拿func来举例
|			|			|-->Item_func::fix_fields()
|			|			|			|-->Item_func_date_format::resolve_type() //不同的func调用不同的resolve_type方法 
```

```c++
//正常表中item_field调用
bool Item_field::fix_fields(THD *thd, Item **reference)
{
  if (!field)         // If field is not checked
  {
    from_field=
      find_field_in_tables(thd, this,
        context->first_name_resolution_table,
        context->last_name_resolution_table,
        reference,
        thd->lex->use_only_table_context ?
           REPORT_ALL_ERRORS : IGNORE_EXCEPT_NON_UNIQUE,
        any_privileges ? 0 : thd->want_privilege,
        true);
   
    set_field(from_field);
  }
}

Field *
find_field_in_table(THD *thd, TABLE *table, const char *name, size_t length, bool allow_rowid, uint *cached_field_index_ptr)
{
  Field **field_ptr, *field;
  uint cached_field_index= *cached_field_index_ptr;
 
  if (cached_field_index < table->s->fields &&
      !my_strcasecmp(system_charset_info,
                     table->field[cached_field_index]->field_name, name))
    field_ptr= table->field + cached_field_index;
  else if (table->s->name_hash.records)
  {
    field_ptr= (Field**) my_hash_search(&table->s->name_hash, (uchar*) name,length);
    if (field_ptr)
    {
      field_ptr= (table->field + (field_ptr - table->s->field));
    }
  }
```

`set_field()`：将字段的元数据从`Field`对象复制到`Item_field`对象中

```c++
table_name= *field_par->table_name;
field_name= field_par->field_name;
db_name= field_par->table->s->db.str;
```



## 2.7 解析所有WHERE和JOIN条件

`Query_block::setup_conds()`实现

1. 调用`m_where_cond->fix_fields`对`m_where_cond` 这个item进行信息绑定。
2. 如果where 条件中有const item`m_where_cond->const_item()`, 则调用`simplify_const_condition()` 进行删除，用`Item_func_true/Item_func_false`来替代整个的条件。**（等值替换）**
3. 最后对`m_table_nest`进行深度优先遍历来对所有Join条件进行绑定 `setup_join_cond(thd, &m_table_nest, it_is_update)`



## 2.8  解析GROUP BY

通过调用`Query_block::setup_group()`实现，该函数遍历group_list，对每个表达式进行绑定，在Select list和FROM后的表中搜索是否存在对应的列，判断是否是合法的GROUP BY语句



## 2.9 解析HAVING

通过对`m_having_cond`调用`fix_fields()`实现



## 2.10 解析rollup

```c++
SELECT year, country, product,
       SUM(profit) AS profit
FROM sales
GROUP BY year, country, product
WITH ROLLUP;

+------+---------+------------+--------+
| year | country | product    | profit |  rollup level
+------+---------+------------+--------+
| 2000 | Finland | Computer   |   1500 |  3  <-- GROUP BY year, country, product
| 2000 | Finland | Phone      |    100 |  3
| 2000 | Finland | NULL       |   1600 |  2  <-- GROUP BY year, country
| 2000 | India   | Calculator |    150 |  3
| 2000 | India   | Computer   |   1200 |  3
| 2000 | India   | NULL       |   1350 |  2  <-- GROUP BY year, country
| 2000 | USA     | Calculator |     75 |  3
| 2000 | USA     | Computer   |   1500 |  3
| 2000 | USA     | NULL       |   1575 |  2  <-- GROUP BY year, country
| 2000 | NULL    | NULL       |   4525 |  1  <-- GROYP BY year
| 2001 | Finland | Phone      |     10 |  3
| 2001 | Finland | NULL       |     10 |  2  <-- GROUP BY year, country
| 2001 | USA     | Calculator |     50 |  3
| 2001 | USA     | Computer   |   2700 |  3
| 2001 | USA     | TV         |    250 |  3
| 2001 | USA     | NULL       |   3000 |  2  <-- GROUP BY year, country
| 2001 | NULL    | NULL       |   3010 |  1  <-- GROUP BY year
| NULL | NULL    | NULL       |   7535 |  0  <-- No GROUP BY
+------+---------+------------+--------+
```

对于 SQL 语句中的每一个聚集函数，都需要同时计算多层 rollup 的结果，MySQL 使用了一个特殊的派生 Item_sum 的封装类 Item_rollup_sum_switcher 来实现。对于每一个聚集函数，都会创建一个新的 Item_rollup_sum_switcher，然后将原聚集函数比如 Item_sum_count 拷贝多份放入 Item_rollup_sum_switcher 的参数列表中(总计 N+1 份，N 为 GROUP BY 的列数)，参数下标对应 rollup 的层次 0, 1, 2, 3。这个过程在 create_rollup_switcher 中实现 （http://mysql.taobao.org/monthly/2024/05/01/）

```c++
SELECT_LEX::prepare
|  		|--SELECT_LEX::mark_item_as_maybe_null_if_rollup_item() // 将all_fields里的表达式标记maybe_null为true，防止常量表达式被优化掉，比如IS NULL
  		|--SELECT_LEX::resolve_rollup() // 遍历all_fields，对聚集函数和分组列进行封装，加入到all_fields中，保持base_ref_items不变
    				|--create_rollup_switcher() // 拷贝多份聚集函数，封装在Item_rollup_sum_switcher
    				|--resolve_rollup_item() // 将参数里的分组列封装在Item_rollup_group_item
 			 		|--如果有split_sum_func加入到all_fields中的聚集函数
    				|--create_rollup_switcher() 
```



## 2.11 解析子查询

`Query_block::resolve_subquery()`

```c++
Query_block::resolve_subquery()
|			|-- 1.semi-join
|			|-- 2.materialization
|			|--Item_in_subselect::select_transformer()
|			|			|--Item_in_subselect::select_in_like_transformer()
|			|			|			|--Item_in_subselect::single_value_transformer()//标量子查询
|			|			|			|--row_value_transformer()
|			|			|			|			|--row_value_in_to_exists_transformer() //in->exists
```

1. 先进行判断能否标记为semi-join

   - 子查询是IN/=ANY和EXIST subquery的谓词
   - 子查询是简单查询块而不是UNION
   - 子查询无隐形和显性的GROUP BY
   - 子查询没有HAVING、WINDOW函数
   - Resolve的阶段是Query_block::RESOLVE_CONDITION和Query_block::RESOLVE_JOIN_NEST并且没有用到最新的Hyper optimizer优化器。
   - 外查询块可以支持semijoins
   - 至少要一个表，而不是类似"SELECT 1"
   - 子查询的策略还没有指定Subquery_strategy::UNSPECIFIED
   - 父查询也至少有一个表
   - 父查询和子查询都不能有straight join
   - 父查询块不禁止semijoin

2. 如果不行，则判断能否标记为materialization方案

   - Optimzier开关subquery_to_derived=on
   - 子查询是IN/=ANY or EXISTS谓词
   - 子查询是简单查询块而不是UNION
   - 如果是[NOT] EXISTS，必须没有聚合
   - Subquery谓词在where子句（目前没有在ON子句实现），而且是ANDs or ORs的表达式
   - 父查询块支持semijoins
   - 父查询也至少有一个表，然后可以做LEFT JOIN
   - 父查询块不禁止semijoin
   - IN谓词返回值是否是确定的，不是RAND

3. 以上方案都不行，则根据不同的子查询类型选择不同的转换方法 `select_transformer`

   a. 标量子查询，在查询中直接用执行结果替换 `Item_singlerow_subselect::select_transformer`

   ```sql
   select * from t1 where a = (select 1); 
   =>
   select * from t1 where a = 1;
   ```

​      b. In->exists转换，子查询策略设定为`Subquery_strategy::CANDIDATE_FOR_IN2EXISTS_OR_MAT`

​          i. 对于`single-column`的的IN/ALL/ANY的子查询，会进行重写

```sql
 SELECT * FROM t1 WHERE b > ANY (SELECT a FROM t2) 
  =>
 with SELECT * FROM t1 WHERE b > (SELECT MIN(a) FROM t2)
```

​           ii. 非single-column 的场景则进行in->exist 转换

```sql
###有having 表达式
(l1, l2, l3) IN (SELECT v1, v2, v3 ... HAVING having) 
=>
EXISTS (SELECT ... HAVING having and
                          (l1 = v1 or is null v1) and
                          (l2 = v2 or is null v2) and
                          (l3 = v3 or is null v3) and
                          is_not_null_test(v1) and
                          is_not_null_test(v2) and
                          is_not_null_test(v3))
###无having表达式
(l1, l2, l3) IN (SELECT v1, v2, v3 ... WHERE where) 
=>
EXISTS (SELECT ... WHERE where and
                         (l1 = v1 or is null v1) and
                         (l2 = v2 or is null v2) and
                         (l3 = v3 or is null v3)
                   [ HAVING is_not_null_test(v1) and
                         is_not_null_test(v2) and
                         is_not_null_test(v3)) ] <-- 保证不为NULL可以去掉HAVING
```

​                      

## 2.12 标量子查询转换为派生表

`transform_scalar_subqueries_to_join_with_derived()`中实现    

实例：

```shell
mysql> set optimizer_switch = 'subquery_to_derived=off';
Query OK, 0 rows affected (0.00 sec)

mysql> EXPLAIN SELECT b, MAX(a) AS ma FROM t0 GROUP BY b HAVING ma < (SELECT MAX(t.a) FROM t WHERE t.b=t0.b);
+----+--------------------+-------+------------+------+---------------+------+---------+------+--------+----------+-----------------+
| id | select_type        | table | partitions | type | possible_keys | key  | key_len | ref  | rows   | filtered | Extra           |
+----+--------------------+-------+------------+------+---------------+------+---------+------+--------+----------+-----------------+
|  1 | PRIMARY            | t0    | NULL       | ALL  | NULL          | NULL | NULL    | NULL | 998568 |   100.00 | Using temporary |
|  2 | DEPENDENT SUBQUERY | t     | NULL       | ALL  | NULL          | NULL | NULL    | NULL |     10 |    10.00 | Using where     |
+----+--------------------+-------+------------+------+---------------+------+---------+------+--------+----------+-----------------+
2 rows in set, 3 warnings (0.01 sec)

mysql> set optimizer_switch = 'subquery_to_derived=on';
Query OK, 0 rows affected (0.00 sec)

mysql> EXPLAIN SELECT b, MAX(a) AS ma FROM t0 GROUP BY b HAVING ma < (SELECT MAX(t.a) FROM t WHERE t.b=t0.b);
+----+-------------+------------+------------+------+---------------+------+---------+------+--------+----------+--------------------------------------------+
| id | select_type | table      | partitions | type | possible_keys | key  | key_len | ref  | rows   | filtered | Extra                                      |
+----+-------------+------------+------------+------+---------------+------+---------+------+--------+----------+--------------------------------------------+
|  1 | PRIMARY     | t0         | NULL       | ALL  | NULL          | NULL | NULL    | NULL | 998568 |   100.00 | Using temporary                            |
|  1 | PRIMARY     | <derived2> | NULL       | ALL  | NULL          | NULL | NULL    | NULL |     10 |   100.00 | Using where; Using join buffer (hash join) |
|  2 | DERIVED     | t          | NULL       | ALL  | NULL          | NULL | NULL    | NULL |     10 |   100.00 | Using temporary                            |
+----+-------------+------------+------------+------+---------------+------+---------+------+--------+----------+--------------------------------------------+
3 rows in set, 3 warnings (0.00 sec)
```

###   大致流程：

  a  收集唯一的聚合函数Item列表（collect_aggregates），这些Item将会被新的Derived Table的列代替

  b 遍历所有可以转换的子查询，把他们转换成derived tables，并替换相应的表达式变成列（transform_subquery_to_derived）

  c  代替WHERE、JOIN、HAVING条件和SELECT list中的子查询的表达式变成对应的Derived Table里面列

###  场景

 Case1:子查询不在连接条件内，使用left join... on true

```sql
SELECT (SELECT COUNT(a) FROM t2) + a FROM t1;
=>
SELECT derived.cnt + t1.a FROM  t1 LEFT OUTER JOIN
 (select COUNT(a) AS cnt FROM t2) AS derived ON TRUE;
```

 Case2: 子查询在连接条件内，则把其嵌套在外部表之后

```sql
SELECT * FROM t1 LEFT JOIN t2 ON (SELECT COUNT(a) AS cnt FROM t2) = t1.a;
=>
SELECT * FROM t1 LEFT JOIN (SELECT COUNT(t2.a) AS cnt FROM t2) derived_1_0 ON(TRUE) 
              LEFT JOIN t2 ON derived_1_0.cnt = t1.a
```

## 2.13 扁平化子查询

通过调用`Query_block::flatten_subquerie()`函数来完成将Semi-join子查询转换为nested JOIN，这个过程只有一次，并且不可逆

case

```sql
mysql> explain analyze SELECT * FROM t1 WHERE t1.a1 in (SELECT t2.c1 FROM t2 where t2.c1 > 0);
+----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
| EXPLAIN                                                                                                     
| -> Hash semijoin (t2.c1 = t1.a1)  (cost=0.70 rows=1) (actual time=0.641..0.641 rows=0 loops=1)
    -> Filter: (t1.a1 > 0)  (cost=0.35 rows=1)
        -> Table scan on t1  (cost=0.35 rows=1) 
    -> Hash
        -> Table scan on t2  (cost=0.35 rows=1) (actual time=0.572..0.572 rows=0 loops=1)
 |
1 row in set (0.00 sec)

等价于
select t1.a1 from t1 semi join t2 where (t1.a1 = t2.c1) and (t1.c1 > 0) 
```

大致流程：

- 创建SEMI JOIN (it1 ... itN)语以部分，并加入到外层查询块的执行计划中
- 将子查询的WHERE条件以及JOIN条件，加入到父查询的WHERE条件中
- 将子查询谓词从父查询的判断谓词中消除



## 2.14 当前查询块转换

通过调用`Query_block::apply_local_transforms()`来完成，local意味着变形只在当前Query_block进行，不会进行Query_block之间的变形。

```c++
Query_block::apply_local_transforms()
|			|--Query_block::delete_unused_merged_columns() //删除不用列
|			|--Query_block::simplify_joins() //用inner join 代替外连接
|			|--prune_partitions() //分区剪枝
|			|--Query_block::push_conditions_to_derived_tables()//谓词下推 
```



1. 
   删除无用的列：如果查询块已经删除了一些derived tables/views，遍历SELECT列表的列，删除不必要的列
2. 简化join：用内连接来代替外连接。把join-list中符合条件的表添加到nest-join list中

```sql
 SELECT * FROM t1 LEFT JOIN t2 ON t2.a=t1.a WHERE t2.b < 5
 =>
 SELECT * FROM t1 INNER JOIN t2 ON t2.a=t1.a WHERE t2.b < 5
 =>
 SELECT * FROM t1, t2 ON t2.a=t1.a WHERE t2.b < 5 AND t2.a=t1.a
```

3. 分区裁剪 `prune_partitions()`
4. 条件下推到派生表 `push_conditions_to_derived_tables()`

```c++
mysql> set optimizer_switch = 'derived_condition_pushdown=off'; 
Query OK, 0 rows affected (0.00 sec)

mysql> set optimizer_switch = 'derived_merge=off';
Query OK, 0 rows affected (0.00 sec)

mysql> EXPLAIN FORMAT=tree SELECT * FROM (SELECT a1,c1 FROM t1) as dt     WHERE c1 > 10;
+-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
| EXPLAIN                                                                                                                                                                                                   |
+-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
| -> Filter: (dt.c1 > 10)  (cost=2.73..2.73 rows=1)
    -> Table scan on dt  (cost=2.96..2.96 rows=1)
        -> Materialize  (cost=0.45..0.45 rows=1)
            -> Table scan on t1  (cost=0.35 rows=1)
 |
+-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
1 row in set (0.00 sec)

mysql> set optimizer_switch = 'derived_condition_pushdown=on';
Query OK, 0 rows affected (0.00 sec)

mysql> EXPLAIN FORMAT=tree SELECT * FROM (SELECT a1,c1 FROM t1) as dt     WHERE c1 > 10;
+-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
| EXPLAIN                                                                                                                                                                                             |
+-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
| -> Table scan on dt  (cost=2.96..2.96 rows=1)
    -> Materialize  (cost=0.45..0.45 rows=1)
        -> Filter: (t1.c1 > 10)  (cost=0.35 rows=1)
            -> Table scan on t1  (cost=0.35 rows=1)
 |
+-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
1 row in set (0.00 sec)
    
```

 大致流程

   a)  遍历derived table列表，判断是否可以下推 `Table_ref::can_push_condition_to_derived()` 如果是以下情况则不能下推

​	Derived table有UNION

​	Derived table有LIMIT

​	Derived table不能是outer join中的内表 （右表）

​	不能是CTE包含的Derived table

  b) 创建可以下推到的Derived table的where cond  `Condition_pushdown::make_cond_for_derived()`

  c) 保留剩余不能下推的条件`Condition_pushdown::get_remainder_cond()`

  d) Top-down递归调用 `push_conditions_to_derived_tables()`



# 三  optimize 阶段



## 3.1 统计临时表中fields信息

通过调用`count_field_types()`来完成，一个JOIN的结果是可能会被物化成临时表的，JOIN的成员变量`Temp_table_param tmp_table_param`记录了物化成的临时表的信息，该函数会遍历fields进行统计。



## 3.2获取query_block中的where，having 拷贝到join中

通过调用`Query_block::get_optimizable_conditions()`来完成



## 3.3 对生成派生表的Query_expression进行optimize

对每个表判断是否是派生表，如果是派生表，通过调用`Table_ref::optimize_derived()`来实现，该函数首先会对派生表的Query_expression调用`Query_expression::optimize()`，然后判断生成的派生表是否是const的，如果是，提前创建物化表并且物化，如果不是，那物化过程在迭代器中正常进行。



## 3.4 Zero Limit优化

如果发现当前JOIN只会返回零行，那么提前调用`JOIN::create_access_paths_for_zero_rows()`创建AccessPath，跳过剩余优化步骤



## 3.5 条件优化

调用`optimize_cond()`来完成，主要做以下工作

a. 等值传播(build_equal_items)

b. 常数传播(propagate_cond_constants)

c. Const and eq item 条件去除（remove_eq_conds）



### 3.5.1 等值传播

```sql
SELECT * FROM (t1,t2) LEFT JOIN (t3,t4) ON t1.a=t3.a AND t2.a=t4.a WHERE t1.a=t2.a
显然t1.a=t2.a=t3.a=t4.a
==>SELECT * FROM (t1,t2) LEFT JOIN (t3,t4) ON t1.a=t3.a AND t3.a=t4.a WHERE t1.a=t2.a
从而连接部分可以改写成 
==>SELECT * FROM (t1 LEFT JOIN (t3,t4) ON t1.a=t3.a AND t3.a=t4.a),t2 WHERE t1.a=t2.a
对t2连接限制被去除，所以将对t2的连接移到外层
==>SELECT * FROM (t1,t2) LEFT JOIN (t3,t4) ON t2.a=t4.a AND t3.a=t4.a WHERE t1.a=t2.a
对t1对连接限制被去除，因为从而连接部分可以改写成
==>SELECT * FROM (t2 LEFT JOIN (t3,t4)ON t2.a=t4.a AND t3.a=t4.a), t1 WHERE t1.a=t2.a
```

**等值传播寻找一个连接条件过滤条件的公共子集，从而可以修改连接的限制，从而让连接优化有更多的可能性**

```c++
|-->build_equal_items()
|		|-->build_equal_items_for_cond() //where cond中构建等价item
|		|-->build_equal_items()//join 条件中将过滤的等价类一并加入，构建所有等价item
```



## 3.5.2 常数传播

`propagate_cond_constants()`实现



## 3.6 调用`JOIN::make_join_plan()`

### 3.6.1 初始化相关变量	

通过调用`JOIN::init_planner_arrays()`函数完成，该函数中初始化了`JOIN_TAB *join_tab`数组，`JOIN_TAB **best_ref`数组，`POSITION *positions`数组，`POSITION *best_positions`数组，`JOIN_TAB **map2table`数组。

- 初始化`JOIN_TAB *join_tab`数组，通过调用`alloc_jtab_array()`函数完成，创建一个等同于Query_block的`leaf_table_count`数量的JOIN_TAB数组。JOIN_TAB类中的`Table_ref *table_ref`指针指向了它对应的Table_ref对象，它额外包含了所有在`make_join_plan()`过程中计算得到的与该Table_ref相关的变量，例如，用于分析ref用到的Keyuse数组，表示表之间依赖关系的table_map变量等。
- 初始化`JOIN_TAB **best_ref`数组，该数组是一个指针数组，代表了当前得到的最好的Partial Join order，index代表了在Join order中序号，值是一个JOIN_TAB指针。
- 初始化`JOIN_TAB **map2table`数组，该数组是一个指针数组，代表了table no和JOIN_TAB之间的对应关系，index代表了table no，值是一个JOIN_TAB指针。
- 初始化`POSITION *positions`数组，该数组是一个POSITION数组，每个POSITION对象中代表了在Join order中的table，里面记录了优化过程中状态信息，例如rowcount，cost，semijoin相关信息等。该数组index代表了Join order中的序号，值是一个POSITION对象。
- 初始化`POSITION *best_positions`数组，该数组是一个POSITION数组，代表了优化过程产生的最终Join order。



### 3.6.2 依赖性传播

通过调用`JOIN::propagate_dependencies()`完成，构建JOIN_TAB之间的依赖性，能够加速外连接的Join order枚举，并且能够捕捉到不合理的交叉引用（出现在recursive cte中）。



## 3.6.3 消除semi-join

在`update_ref_and_keys()` 之后，如果 semijoin 的内表是可以 eq_ref(唯一索引) 外表，且 (sj-nest) 中不存在其他内表依赖它，那么该表就可以从 (sj-nest) 中移出来，放置在外层的 join list 中，因为这样的表和外层表 join 是不会产生数据膨胀的。这样可以简化 (sj-nest) 的内表结构，如果所有的内表都可以被提出来，那么 (sj-nest) 就可以被直接移除，消除了 semijoin。



## 3.7 单表行数估计

通过调用`JOIN::estimate_rowcount()`完成，该函数会针对每个参与Join的单表计算 读const表，全表扫描，覆盖索引扫描，索引范围扫描，skip scan，index merge等多种AccessPath的代价和估计的输出行数。 在行数估计过程中，会把一个复杂的WHERE条件用SEL_TREE结构来表示。SEL_TREE是可以简单理解为一个多个红黑树构成的森林，一个key_part上的所有不相邻区间按照顺序表示为一个红黑树，不同的key_part按照在Key中顺序关系通过next_key_part指针相连，以下面的SQL和图为例：

```
SELECT *
FROM t1
WHERE (kp1 < 1
    AND kp2 = 5
    AND (kp3 = 10
    OR kp3 = 12))
    OR (kp1 = 2
    AND (kp3 = 11
    OR kp3 = 14))
    OR (kp1 = 3
    AND (kp3 = 11
    OR kp3 = 14));
```

![SEL_TREE](http://mysql.taobao.org/monthly/pic/202412/yuanqi_pic/SEL_tree.png)

该函数会根据代价选择出最佳的单表AccessPath，但会把所有计算了代价的索引的估计输出行数保存在quick_rows中，用在后续的ref行数估计中。



## 3.8 创建QEP_TAB数组

通过调用`alloc_qep()`函数来完成，该函数会为每个best_ref中的每个JOIN_TAB都创建一个QEP_TAB对象。JOIN_TAB可以理解为是`JOIN::make_join_plan()`过程中对每个表的抽象，而QEP_TAB实在生成执行器时对每个表的抽象。在创建完QEP_TAB后，会通过`QEP_TAB::init(JOIN_TAB *jt)`函数来将JOIN_TAB中需要共享的数据传递给QEP_TAB。其实，JOIN_TAB和QEP_TAB都继承了`QEP_shared_owner`，只不过他们额外保存了在各自阶段所需的对表的信息。
